setwd("snp_analysis")

isbetween <- function(number,bound1,bound2) {return((bound1>=number & number>=bound2)|(bound2>=number & number>=bound1))} 
# Function "isbetween" takes three numbers "number", "bound1", and "bound2" and returns a boolean true if 
# "number" is between "bound1" and "bound2" and false if otherwise.
isbetweenadjust <- function(number,bound1,bound2) {return(bound1>number & number>=bound2)}
# Function "isbetweenadjust" is like "isbetween" except with a modification such that "bound1" is excluded 
# as an acceptable value for "number" for the boolean to return true.

metabConverter <- function(metab,mapper1,mapper2,mapmetab) {  
  index1<-grep(metab,mapper1[,5],fixed=TRUE)
  if(length(index1)!=0){
    for(i in index1){
      if(mapper1[i,5]==metab){
        index2<-match(mapper1[i,8],mapper2[,6])
        if(!is.na(index2)){
          index3<-match(mapper2[index2,1],mapmetab[,1])
          if(!is.na(index3)){
            return(c(TRUE,index3,mapper2[index2,1]))
          }
        }
      }
    }
  }
  return(FALSE)
}
# Function "metabConverter" takes the EC number "metab" as input, checks it with the first mapping file "mapper1" 
# (Bill Riehl's compound_to_ec file in this case), takes the corresponding KEGG ID,
# checks that KEGG ID against the second mapping file "mapper2" (Northen Lab's preliminary datatable) 
# and then finds the corresponding metabolite name, then searches the significantly changing metabolite
# datasheet with the name. Returns true if the metabolite is found, also returns the index of the match, 
# and the name of the metabolite. Returns false if else. The reason for this function is that the
# naming conventions aren't the same between the Northen Lab data and the MO data.


# Make sure that args[4] - args[8] and args[9] - args[10] are called in the same order as 
# args[6] and args[11] are used in the initial MAUVE alignment.
blast = read.table("blastn.out",fill=T,sep="\n",quote="")
# blastProcessor.R must first be run, as well as runblast.txt on the path usr2/people/kevinmeng/Mauve/NecessaryBits/runblast.txt

TFsite <- read.table("BindingSiteSet.txt",fill=T,sep="\t")
TFgene <- read.table("network_tf_gene.txt",fill=T,sep="\t")
sigmagene <- read.table("network_sigma_gene.txt",fill=T,sep="\t")
# The above 3 are datasets from RegulonDB, for the mapping of TF sequence to TF name to the gene that the TF regulates.

alignment <- as.matrix(read.table("Alignment.txt",fill=T,sep="\t"))
# Output from Mauve.

mapper <- read.table("compound_to_ec.txt",sep="\t",header=T,fill=T)
# Bill Riehl's mapping file.

northen <- read.table("GC_KEIO_Xcheng.txt",sep="\t",header=T,fill=T)
# The Northen Lab original dataset.

tabdata <- read.table("511145.tab",sep="\t",header=T,fill=T,quote="")
# The tab-delimited file from MO.
protdata <- read.table("511145.proteomes.fasta",sep="\n",header=F,quote="")
# The proteome file from MO.
genome <- read.table("511145.genome.fasta",sep="\t",header=T)
# The genome file from MO.
ortho <- read.table("511145_ortho.txt",sep="\t",header=T)
# The ortholog file generated by Marcin's perl script.
metab <- read.table("HG1655_metabolites_MG1655_HS_dropminrep.txt",sep="\t",header=T,fill=T)
# The significantly changing metabolite file pertaining to this pair of strains.

seq1 = ""
seq2 = ""

for (i in 1:length(alignment[,1])){
  line = alignment[i,1]
  string = strsplit(line,"")[[1]]
  if (string[1]==">"&&i!=1) {
    seq1 = alignment[2:(i-1),1]
    seq2 = alignment[(i+1):(length(alignment[,1])-1),1]
  }
}
# Parses the alignment file by dividing the aligned sequences into seq1 and seq2.

seq1 = paste(seq1,collapse="\n")
seq1 = gsub("\n","",seq1)
seq1 = strsplit(seq1,"")[[1]]

seq2 = paste(seq2,collapse="\n")
seq2 = gsub("\n","",seq2)
seq2 = strsplit(seq2,"")[[1]]
# Converts seq1 and seq2 into list form, rather than string form.

###### Parsing section 1
tab1 = tabdata

sequence = ""
id = NULL
proteo1 = NULL

for (i in 1:length(protdata[,1])){
  line = as.character(protdata[i,1])
  string = strsplit(line,"")[[1]]
  if (string[1]==">") {
    string = paste(string,collapse="")
    id = strsplit(string," ")[[1]][1]
    id = gsub(">VIMSS","",id)
  }
  
  if(line==toupper(line)) {
    sequence = paste(sequence,line)
    sequence = gsub(" ","",sequence)
    if(i < length(protdata[,1]) && (as.character(protdata[i+1,1])!=toupper(as.character(protdata[i+1,1])))) {
      proteo1 = rbind(proteo1,cbind(id,sequence))
      sequence = ""
    }
    if(i == length(protdata[,1])) {
      proteo1 = rbind(proteo1,cbind(id,sequence))
      sequence = ""
    }
  }
}

# Parses the proteome file such that the first column is the vimss id and the second is the sequence.

gen1 <- gsub("\n","",paste(genome[,1],sep="",collapse="\n"))
# Parses genome file into continuous string, removing the newline chars.
orth1 <- ortho
met1 <- cbind(rownames(metab),metab)
# Reassign the ortholog file to orth1 for better organization, and changes the rownames of 
# metab into a column of names to the left of the original metab matrix.

tabdata <- read.table("331112.tab",sep="\t",header=T,fill=T,quote="")
protdata <- read.table("331112.proteomes.fasta",sep="\n",header=F,quote="")
genome <- read.table("331112.genome.fasta",sep="\t",header=T)
ortho <- read.table("331112_ortho.txt",sep="\t",header=T)
metab <- read.table("HS_metabolites_MG1655_HS_dropminrep.txt",sep="\t",header=T,fill=T)

###### Parsing section 2 # Repeats parsing section 1 except for the second strain that is being compared.
tab2 = tabdata

sequence = ""
id = NULL
proteo2 = NULL

for (i in 1:length(protdata[,1])){
  line = as.character(protdata[i,1])
  string = strsplit(line,"")[[1]]
  if (string[1]==">") {
    string = paste(string,collapse="")
    id = strsplit(string," ")[[1]][1]
    id = gsub(">VIMSS","",id)
  }
  
  if(line==toupper(line)) {
    sequence = paste(sequence,line)
    sequence = gsub(" ","",sequence)
    if(i < length(protdata[,1]) && (as.character(protdata[i+1,1])!=toupper(as.character(protdata[i+1,1])))) {
      proteo2 = rbind(proteo2,cbind(id,sequence))
      sequence = ""
    }
    if(i == length(protdata[,1])) {
      proteo2 = rbind(proteo2,cbind(id,sequence))
      sequence = ""
    }
  }
}

gen2 <- gsub("\n","",paste(genome[,1],sep="",collapse="\n"))
orth2 <- ortho
met2 <- cbind(rownames(metab),metab)

###### SNP Generator and InDel Detector

snps = NULL

counter1 = 0
counter2 = 0
indel1 = NULL
indel2 = NULL
start1 = 1
start2 = 1
gapgenes1 = NULL
gapgenes2 = NULL
laststop1 = 1
laststop2 = 1
count1 = 0
count2 = 0
missing = F
endgap1 = F
endgap2 = F

for(char in 1:length(seq1)){
  print(char)
  if (seq1[char]!=seq2[char] && seq1[char]!="-" && seq2[char]!="-") {
    snps = rbind(snps,cbind(paste(seq1[char],seq2[char],sep=""),(char-counter1),(char-counter2),char))
  }
  # Creates the file of SNPs to mimic the format of the Mauve output. First column is the SNPs of the two strains, concatenated in one string.
  # Second column is the index of the SNP for the first strain, relative to that strain's genome. Third column is the index of the SNP for 
  # the second strain, relative to that strain's genome. The fourth column is the aligned index for both SNPs, for testing purposes.
  if (seq1[char] == "-") {
    counter1 = counter1+1
    if (char != 1 && seq1[char-1]!="-"){
      indel1 = c(indel1, char)
    }
    if (char != (length(seq1)-1) && seq1[char+1]!="-"){
      endgap1 = T
      indel1 = c(indel1, char)
      for (bound in laststop1:length(tab2[,1])) {
        gapstart = indel1[start1]
        gapend = indel1[start1+1]
        if (tab2[bound,7] == '+') {
          start = 5
          end = 6
        }
        if (tab2[bound,7] == '-') {
          start = 6
          end = 5
        }
        starter = tab2[bound,start] + count2
        ender = tab2[bound,end] + count2
        if (starter <= gapstart && gapstart <= ender && gapend > ender && (ender - gapstart) > .5*(ender - starter)) {
          howmuch = (ender - gapstart) / (ender - starter)
          missing = T
          break
        }
        if (starter <= gapend && gapend <= ender && gapstart < starter && (gapend - starter) > .5*(ender - starter)) {
          howmuch = (gapend - starter) / (ender - starter)
          missing = T
          break
        }
        if (starter <= gapstart && gapstart <= ender && starter <= gapend && gapend <= ender && (gapend - gapstart) > .5*(ender - starter)) {
          howmuch = (gapend - gapstart) / (ender - starter)
          missing = T
          break
        }
        if (gapstart <= starter && gapend >= ender) {
          howmuch = 1
          missing = T
          break
        }
      }
      if (missing){
        gapgenes2 = rbind(gapgenes2, cbind(tab2[bound,1],indel1[start1],indel1[start1+1],howmuch))
        laststop1 = bound
        missing = F
      }
    }
  }
  
  if (seq2[char] == "-") {
    counter2 = counter2+1
    if (char != 0 && seq2[char-1]!="-"){
      indel2 = c(indel2, char)
    }
    if (char != (length(seq2)-1) && seq2[char+1]!="-"){
      endgap2 = T
      indel2 = c(indel2, char)
      for (bound in laststop2:length(tab1[,1])) {
        gapstart = indel2[start2]
        gapend = indel2[start2+1]
        if (tab1[bound,7] == '+') {
          start = 5
          end = 6
        }
        if (tab1[bound,7] == '-') {
          start = 6
          end = 5
        }
        starter = tab1[bound,start] + count1
        ender = tab1[bound,end] + count1
        if (starter <= gapstart && gapstart <= ender && gapend > ender && (ender - gapstart) > .5*(ender - starter)) {
          howmuch = (ender - gapstart) / (ender - starter)
          missing = T
          break
        }
        if (starter <= gapend && gapend <= ender && gapstart < starter && (gapend - starter) > .5*(ender - starter)) {
          howmuch = (gapend - starter) / (ender - starter)
          missing = T
          break
        }
        if (starter <= gapstart && gapstart <= ender && starter <= gapend && gapend <= ender && (gapend - gapstart) > .5*(ender - starter)) {
          howmuch = (gapend - gapstart) / (ender - starter)
          missing = T
          break
        }
        if (gapstart <= starter && gapend >= ender) {
          howmuch = 1
          missing = T
          break
        }
      }
      if (missing){
        gapgenes1 = rbind(gapgenes1, cbind(tab1[bound,1],indel2[start2],indel2[start2+1],howmuch))        
        laststop2 = bound
        missing = F
      }
    }
  }
  if (endgap1) {
    endgap1 = F
    start1 = length(indel1)+1
    count1 = counter1
  }
  if (endgap2) {
    endgap2 = F
    start2 = length(indel2)+1
    count2 = counter2
  }
  # Walks both aligned sequences, checking for deletions by looking at strain 2's sequence wherever there is a set of missing characters
  # in strain 1, and vice versa. Gathers a list of missing genes in gapgenes1 and gapgenes2.
}

write.table(gapgenes1,"511145.missinggenes.txt",sep="\t",col.names=NA)
write.table(gapgenes2,"331112.missinggenes.txt",sep="\t",col.names=NA)

###### Collection

genomelength = nchar(genome)

snps_nuc = as.character(snps[,1])
snpscol1 = as.numeric(snps[,2])
snpscol2 = as.numeric(snps[,3])
upstr1 = mat.or.vec(length(snps[,1]),3)
downstr1 = mat.or.vec(length(snps[,1]),2)
coding1 = mat.or.vec(length(snps[,1]),2)
prot1 = mat.or.vec(length(snps[,1]),3)
tab1_orient = as.character(tab1[,7])
tab1_bound1 = tab1[,5]
tab1_bound2 = tab1[,6]
tab1_ec = as.character(tab1[,17])
tab1_vimss = as.character(tab1[,1])
proteo1_vimss = as.character(proteo1[,1])
frame1 = 1
nextframe1 = 1
prev1 = 0

upstr2 = mat.or.vec(length(snps[,1]),3)
downstr2 = mat.or.vec(length(snps[,1]),2)
coding2 = mat.or.vec(length(snps[,1]),2)
prot2 = mat.or.vec(length(snps[,1]),3)
tab2_orient = as.character(tab2[,7])
tab2_bound1 = tab2[,5]
tab2_bound2 = tab2[,6]
tab2_ec = as.character(tab2[,17])
tab2_vimss = as.character(tab2[,1])
proteo2_vimss = as.character(proteo2[,1])
frame2 = 1
nextframe2 = 1
prev2 = 0

runtime = proc.time()

for(i in 1:length(snps[,1])) {
  # for(i in 33300:33400) {
  
  for(j in frame1:length(tab1[,1])) {
    bound1 = tab1[j,5]
    bound2 = tab1[j,6]
    orient = tab1_orient[j]
    vimss <- tab1_vimss[j]
    if (length(tab1[,1]) > j && j > 1) {
      orient1 = tab1_orient[(j-1)]
      orient2 = tab1_orient[(j+1)]
      previous = 0 + as.numeric(orient1=="+")*tab1_bound2[(j-1)] + as.numeric(orient1=="-")*tab1_bound1[(j-1)] # Checks the previous gene's coordinates and sets as bound for UTR.
      following = 0 + as.numeric(orient2=="+")*tab1_bound1[(j+1)] + as.numeric(orient2=="-")*tab1_bound2[(j+1)]
    } else if (j == length(tab1[,1])) {
      orient1 = tab1_orient[(j-1)]
      previous = 0 + as.numeric(orient1=="+")*tab1_bound2[(j-1)] + as.numeric(orient1=="-")*tab1_bound1[(j-1)]
      following = genomelength
    } else if (j == 1) {
      orient2 = tab1_orient[(j+1)]
      previous = 0
      following = 0 + as.numeric(orient2=="+")*tab1_bound1[(j+1)] + as.numeric(orient2=="-")*tab1_bound2[(j+1)]
    }
    if(orient == "+") {
      start <- bound1
      end <- bound2
      upstream <- as.integer(start - 500 + (as.numeric(start - 500 < previous)*(previous - (start - 500))))
      downstream <- as.integer(end + 100 - (as.numeric(end + 100 > following)*(end + 100 - following)))
      if(previous > start) {upstream = start}
    }
    if(orient == "-") {
      start <- bound2
      end <- bound1
      upstream <- as.integer(end + 500 - (as.numeric(end + 500 > following)*(end + 500 - following)))
      downstream <- as.integer(start - 100 + (as.numeric(start - 100 < previous)*(previous - (start - 100))))
      if(previous > start) {downstream = start}
      temp = start
      start = end
      end = temp
    }
    now = min(upstream,downstream)
    if(prev1 < now) {nextframe1 = j-1}
    prev1 = max(upstream,downstream)
    if(isbetweenadjust(snpscol1[i],start,upstream)) {
      upstr1[i,1] <- vimss
      upstr1[i,2] <- substr(snps_nuc[i],1,1)
      upstr1[i,3] <- snpscol1[i]
    }
    if(isbetweenadjust(snpscol1[i],end,downstream)) {
      downstr1[i,1] <- vimss
      downstr1[i,2] <- substr(snps_nuc[i],1,1)
    }
    if(isbetween(snpscol1[i],bound1,bound2)) { # Coding region SNPs
      coding1[i,1] = vimss
      coding1[i,2] = substr(snps_nuc[i],1,1)
      if(tab1[j,7] == "+") {
        x = snpscol1[i]
        y = bound1
      }
      if(tab1[j,7] == "-") {
        y = snpscol1[i]
        x = bound1
      }
      trans <- ceiling((x-y)/3)
      if (trans == 0) {trans = 1}
      index = match(vimss,proteo1_vimss)
      if(!is.na(index)) {
        prot1[i,1]=vimss
        prot1[i,2]=substr(proteo1[index,2],trans,trans)
        prot1[i,3]=trans
      }
      # print(cat("SNP present in gene", vimss, upstr, start, end, downstr, snps[j,column], sep="\t"))
    }
    if((snpscol1[i] < now)) {
      break
    }
  }
  if(frame1<nextframe1){frame1=nextframe1}
  
  for(j in frame2:length(tab2[,1])) {
    bound1 = tab2[j,5]
    bound2 = tab2[j,6]
    orient = tab2_orient[j]
    vimss <- tab2_vimss[j]
    if (length(tab2[,1]) > j && j > 1) {
      orient1 = tab2_orient[(j-1)]
      orient2 = tab2_orient[(j+1)]
      previous = 0 + as.numeric(orient1=="+")*tab2_bound2[(j-1)] + as.numeric(orient1=="-")*tab2_bound1[(j-1)] # Checks the previous gene's coordinates and sets as bound for UTR.
      following = 0 + as.numeric(orient2=="+")*tab2_bound1[(j+1)] + as.numeric(orient2=="-")*tab2_bound2[(j+1)]
    } else if (j == length(tab2[,1])) {
      orient1 = tab2_orient[(j-1)]
      previous = 0 + as.numeric(orient1=="+")*tab2_bound2[(j-1)] + as.numeric(orient1=="-")*tab2_bound1[(j-1)]
      following = genomelength
    } else if (j == 1) {
      orient2 = tab2_orient[(j+1)]
      previous = 0
      following = 0 + as.numeric(orient2=="+")*tab2_bound1[(j+1)] + as.numeric(orient2=="-")*tab2_bound2[(j+1)]
    }
    if(orient == "+") {
      start <- bound1
      end <- bound2
      upstream <- start - 500 + (as.numeric(start - 500 < previous)*(previous - (start - 500)))
      downstream <- end + 100 - (as.numeric(end + 100 > following)*(end + 100 - following))
      if(previous > start) {upstream = start}
      
    }
    if(orient == "-") {
      start <- bound2
      end <- bound1
      upstream <- end + 500 - (as.numeric(end + 500 > following)*(end + 500 - following))
      downstream <- start - 100 + (as.numeric(start - 100 < previous)*(previous - (start - 100)))
      if(previous > start) {downstream = start}
      temp = start
      start = end
      end = temp
    }
    now = min(upstream,downstream)
    if(prev2 < now) {nextframe2 = j-1}
    prev2 = max(upstream,downstream)
    if(isbetweenadjust(snpscol2[i],start,upstream)) {
      upstr2[i,1] <- vimss
      upstr2[i,2] <- substr(snps_nuc[i],2,2)
      upstr2[i,3] <- snpscol2[i]
    }
    if(isbetweenadjust(snpscol2[i],end,downstream)) {
      downstr2[i,1] <- vimss
      downstr2[i,2] <- substr(snps_nuc[i],2,2)
    }
    if(isbetween(snpscol2[i],bound1,bound2)) {
      coding2[i,1] = vimss
      coding2[i,2] = substr(snps_nuc[i],2,2)
      if(tab2[j,7] == "+") {
        x = snpscol2[i]
        y = bound1
      }
      if(tab2[j,7] == "-") {
        y = snpscol2[i]
        x = bound1
      }
      trans <- ceiling((x-y)/3)
      if (trans == 0) {trans = 1}
      index = match(vimss,proteo2_vimss)
      if(!is.na(index)) {
        prot2[i,1]=vimss
        prot2[i,2]=substr(proteo2[index,2],trans,trans)
        prot2[i,3]=trans
      }
    }
    if((snpscol2[i] < now)) {
      break
    }
  }
  if(frame2<nextframe2){frame2=nextframe2}
  print(snps[i,])
  
}
# Takes the parsed snp, tab, and proteome files to search the snp file's indices and see if they fall in the bounds of the genes as listed in the tab file.
# If a snp falls into the bounds, it'll check the proteome file, translate the indices from the tab file and snp to find the corresponding amino acid mutation.
# Also creates a vector of upstream and downstream snps.

coding1_vimss = coding1[,1]
coding2_vimss = coding2[,1]

proc.time() - runtime

syn1 = mat.or.vec(length(snps[,1]),1)
synindices = which(prot1[,2]==prot2[,2])
syn1[synindices] = prot1[synindices,1]
nonsyn1 = mat.or.vec(length(snps[,1]),1)
nonsynindices = which(prot1[,2]!=prot2[,2])
nonsyn1[nonsynindices] = prot1[nonsynindices,1]

syn2 = mat.or.vec(length(snps[,1]),1)
synindices = which(prot1[,2]==prot2[,2])
syn2[synindices] = prot2[synindices,1]
nonsyn2 = mat.or.vec(length(snps[,1]),1)
nonsynindices = which(prot1[,2]!=prot2[,2])
nonsyn2[nonsynindices] = prot2[nonsynindices,1]

# Compares the list of amino acid mutations from both strains. If not equal, they form the list of the nonsyn1 and nonsyn2 vectors (nonsynonymous mutations).
# If equal, they form the list of the syn1 and syn2 vectors (synonymous mutations).

mastertable1 = mat.or.vec(length(tab1_vimss),23)
mastertable1[,2:17] = as.numeric(mastertable1[,2:17])
mastertable1[,1] = tab1_vimss
mastertable1[,18] = tab1_ec
mastertable2 = mat.or.vec(length(tab2_vimss),23)
mastertable2[,1] = tab2_vimss
mastertable2[,18] = tab2_ec

for(i in 1:length(snps[,1])) {
  index1 = match(upstr1[i,1],mastertable1[,1])  
  index2 = match(syn1[i],mastertable1[,1])
  index3 = match(nonsyn1[i],mastertable1[,1])  
  index4 = match(downstr1[i,1],mastertable1[,1])  
  if(!is.na(index1)){
    if(upstr1[i,2]=="A") {mastertable1[index1,2] = as.numeric(mastertable1[index1,2])+1}
    if(upstr1[i,2]=="T") {mastertable1[index1,3] = as.numeric(mastertable1[index1,3])+1}
    if(upstr1[i,2]=="C") {mastertable1[index1,4] = as.numeric(mastertable1[index1,4])+1}
    if(upstr1[i,2]=="G") {mastertable1[index1,5] = as.numeric(mastertable1[index1,5])+1}
  }
  if(!is.na(index2)){
    if(coding1[i,2]=="A") {mastertable1[index2,6] = as.numeric(mastertable1[index2,6])+1}
    if(coding1[i,2]=="T") {mastertable1[index2,7] = as.numeric(mastertable1[index2,7])+1}
    if(coding1[i,2]=="C") {mastertable1[index2,8] = as.numeric(mastertable1[index2,8])+1}
    if(coding1[i,2]=="G") {mastertable1[index2,9] = as.numeric(mastertable1[index2,9])+1}
  }
  if(!is.na(index3)){
    if(coding1[i,2]=="A") {mastertable1[index3,10] = as.numeric(mastertable1[index3,10])+1}
    if(coding1[i,2]=="T") {mastertable1[index3,11] = as.numeric(mastertable1[index3,11])+1}
    if(coding1[i,2]=="C") {mastertable1[index3,12] = as.numeric(mastertable1[index3,12])+1}
    if(coding1[i,2]=="G") {mastertable1[index3,13] = as.numeric(mastertable1[index3,13])+1}
  }
  if(!is.na(index4)){
    if(downstr1[i,2]=="A") {mastertable1[index4,14] = as.numeric(mastertable1[index4,14])+1}
    if(downstr1[i,2]=="T") {mastertable1[index4,15] = as.numeric(mastertable1[index4,15])+1}
    if(downstr1[i,2]=="C") {mastertable1[index4,16] = as.numeric(mastertable1[index4,16])+1}
    if(downstr1[i,2]=="G") {mastertable1[index4,17] = as.numeric(mastertable1[index4,17])+1}
  }
  
  index1 = match(upstr2[i,1],mastertable2[,1])  
  index2 = match(syn2[i],mastertable2[,1])
  index3 = match(nonsyn2[i],mastertable2[,1])  
  index4 = match(downstr2[i,1],mastertable2[,1])  
  if(!is.na(index1)){
    if(upstr2[i,2]=="A") {mastertable2[index1,2] = as.numeric(mastertable2[index1,2])+1}
    if(upstr2[i,2]=="T") {mastertable2[index1,3] = as.numeric(mastertable2[index1,3])+1}
    if(upstr2[i,2]=="C") {mastertable2[index1,4] = as.numeric(mastertable2[index1,4])+1}
    if(upstr2[i,2]=="G") {mastertable2[index1,5] = as.numeric(mastertable2[index1,5])+1}
  }
  if(!is.na(index2)){
    if(coding2[i,2]=="A") {mastertable2[index2,6] = as.numeric(mastertable2[index2,6])+1}
    if(coding2[i,2]=="T") {mastertable2[index2,7] = as.numeric(mastertable2[index2,7])+1}
    if(coding2[i,2]=="C") {mastertable2[index2,8] = as.numeric(mastertable2[index2,8])+1}
    if(coding2[i,2]=="G") {mastertable2[index2,9] = as.numeric(mastertable2[index2,9])+1}
  }
  if(!is.na(index3)){
    if(coding2[i,2]=="A") {mastertable2[index3,10] = as.numeric(mastertable2[index3,10])+1}
    if(coding2[i,2]=="T") {mastertable2[index3,11] = as.numeric(mastertable2[index3,11])+1}
    if(coding2[i,2]=="C") {mastertable2[index3,12] = as.numeric(mastertable2[index3,12])+1}
    if(coding2[i,2]=="G") {mastertable2[index3,13] = as.numeric(mastertable2[index3,13])+1}
  }
  if(!is.na(index4)){
    if(downstr2[i,2]=="A") {mastertable2[index4,14] = as.numeric(mastertable2[index4,14])+1}
    if(downstr2[i,2]=="T") {mastertable2[index4,15] = as.numeric(mastertable2[index4,15])+1}
    if(downstr2[i,2]=="C") {mastertable2[index4,16] = as.numeric(mastertable2[index4,16])+1}
    if(downstr2[i,2]=="G") {mastertable2[index4,17] = as.numeric(mastertable2[index4,17])+1}
  }
}
# Starts to create the mastertables. Counts the number of nucleotides that fall into each category: synonymous, nonsynonymous, upstream, downstream. Divides
# the count into the four nucleotides.

mapped = NULL
for(i in which(mastertable1[,18]!="")) {
  eclist <- strsplit(mastertable1[i,18],",")[[1]]
  commaSep1 <- ""
  commaSep2 <- ""
  commaSep3 <- ""
  commaSep4 <- ""
  commaSep5 <- ""
  for(j in 1:length(eclist)) {
    output <- metabConverter(eclist[j],mapper,northen,met1)
    if(output[1]){
      index <- as.numeric(output[2])
      mapped = c(mapped,j)
      if(commaSep1 == ""){commaSep1 <- paste(met1[index,1])}
      else {commaSep1 <- paste(commaSep1,",",met1[index,1])}
      if(commaSep2 == ""){commaSep2 <- paste(met1[index,2])}
      else {commaSep2 <- paste(commaSep2,",",met1[index,2])}
      if(commaSep3 == ""){commaSep3 <- paste(met1[index,3])}
      else {commaSep3 <- paste(commaSep3,",",met1[index,3])}
      if(commaSep4 == ""){commaSep4 <- paste(met1[index,4])}
      else {commaSep4 <- paste(commaSep4,",",met1[index,4])}
      if(commaSep5 == ""){commaSep5 <- paste(met1[index,5])}
      else {commaSep5 <- paste(commaSep5,",",met1[index,5])}
    }
  }
  mastertable1[i,18] = paste(eclist[mapped],collapse=",")
  mapped=NULL
  mastertable1[i,19:23] = cbind(commaSep1,commaSep2,commaSep3,commaSep4,commaSep5)
}
# Creates comma-separated list of metabolite names by searching each EC number that corresponds to each gene in the mastertable. Concatenates to
# the mastertable. For the first strain in the comparison.

mapped = NULL
for(i in which(mastertable2[,18]!="")) {
  eclist <- strsplit(mastertable2[i,18],",")[[1]]
  commaSep1 <- ""
  commaSep2 <- ""
  commaSep3 <- ""
  commaSep4 <- ""
  commaSep5 <- ""
  for(j in 1:length(eclist)) {
    output <- metabConverter(eclist[j],mapper,northen,met2)
    if(output[1]){
      index <- as.numeric(output[2])
      mapped = c(mapped,j)
      if(commaSep1 == ""){commaSep1 <- paste(met2[index,1])}
      else {commaSep1 <- paste(commaSep1,",",met2[index,1])}
      if(commaSep2 == ""){commaSep2 <- paste(met2[index,2])}
      else {commaSep2 <- paste(commaSep2,",",met2[index,2])}
      if(commaSep3 == ""){commaSep3 <- paste(met2[index,3])}
      else {commaSep3 <- paste(commaSep3,",",met2[index,3])}
      if(commaSep4 == ""){commaSep4 <- paste(met2[index,4])}
      else {commaSep4 <- paste(commaSep4,",",met2[index,4])}
      if(commaSep5 == ""){commaSep5 <- paste(met2[index,5])}
      else {commaSep5 <- paste(commaSep5,",",met2[index,5])}
    }
  }
  mastertable2[i,18] = paste(eclist[mapped],collapse=",")
  mapped = NULL
  mastertable2[i,19:23] = cbind(commaSep1,commaSep2,commaSep3,commaSep4,commaSep5)
}
# Creates comma-separated list of metabolite names by searching each EC number that corresponds to each gene in the mastertable. Concatenates to
# the mastertable. For the second strain in the comparison.

TFcolumn1 <- NULL
sigmacolumn1 <- NULL

for(i in 1:length(tab1[,1])) {
  TF = ""
  sigma = ""
  index <- which(as.character(TFgene$V2)==as.character(tab1$name[i]))
  if(length(index)!=0) {
    for(j in index) {
      TF = paste(TF, TFgene$V1[j])      
    }
  }
  TFcolumn1 = c(TFcolumn1,TF)
  index <- grep(as.character(tab1$name[i]),as.character(sigmagene$V2))
  if(length(index)!=0) {
    for(j in index) {
      sigma = paste(sigma,sigmagene$V1[j])
    }
  }
  sigmacolumn1 = c(sigmacolumn1,sigma)
}

TFcolumn2 <- NULL
sigmacolumn2 <- NULL

for(i in 1:length(tab2[,1])) {
  TF = ""
  sigma = ""
  index <- which(as.character(TFgene$V2)==as.character(tab2$name[i]))
  if(length(index)!=0) {
    for(j in index) {
      TF = paste(TF,TFgene$V1[j])
    }
  }
  TFcolumn2 = c(TFcolumn2,TF)
  index <- grep(as.character(tab2$name[i]),as.character(sigmagene$V2))
  if(length(index)!=0) {
    for(j in index) {
      sigma = paste(sigma,sigmagene$V1[j])
    }
  }
  sigmacolumn2 = c(sigmacolumn2,sigma)
}
# Parses the regulondb datasets.

ortho1 <- NULL
for(i in 1:length(mastertable1[,1])) {
  index1 <- match(mastertable1[i,1],orth1[,1])
  index2 <- match(orth1[index1,2],orth2[,1])
  if(!is.na(index1) && !is.na(index2)) {
    ortho1 <- c(ortho1,orth1[index1,2])
  } else {ortho1 <- c(ortho1,"no ortholog")}
}

ortho2 <- NULL
for(i in 1:length(mastertable2[,1])) {
  index1 <- match(mastertable2[i,1],orth2[,1])
  index2 <- match(orth2[index1,2],orth1[,1])
  if(!is.na(index1) && !is.na(index2)) {
    ortho2 <- c(ortho2,orth2[index1,2])
  } else {ortho2 <- c(ortho2,"no ortholog")}
}
# Marks whether or not the genes in the mastertable have an ortholog or not.

mastertable1 = cbind(mastertable1,TFcolumn1,sigmacolumn1,ortho1)
mastertable2 = cbind(mastertable2,TFcolumn2,sigmacolumn2,ortho2)
# Concatenates the TF site and sigma site data to the mastertables.

codingsnp1 <- NULL
codingsnp1nometab <- NULL
upstream1 <- NULL
upstream1nometab <- NULL
Nothing1 <- NULL
Missing1 <- NULL
Present1 <- NULL
maxratio1 <- NULL
for(i in 1:length(mastertable1[,1])) {    
  if(length(grep(",",mastertable1[i,20]))!=0) {
    ratios <- strsplit(mastertable1[i,20],",")[[1]]
    absmax = which.max(abs(as.numeric(ratios)))
    maxratio1 <- c(maxratio1,ratios[absmax])
  } else {maxratio1 <- c(maxratio1, mastertable1[i,20])}
  if(sum(as.numeric(mastertable1[i,6:9]))>0){
    if(mastertable1[i,19]!="") {codingsnp1 <- rbind(codingsnp1,c(mastertable1[i,1],as.numeric(mastertable1[i,2:17]),mastertable1[i,18:26],""))} 
    else {codingsnp1nometab <- rbind(codingsnp1nometab,c(mastertable1[i,1],as.numeric(mastertable1[i,2:17]),mastertable1[i,18:26],""))}
  }
  if(sum(as.numeric(mastertable1[i,6:9]))==0 && sum(as.numeric(mastertable1[i,2:5]))>0) {
    if(mastertable1[i,19]!="") {upstream1 <- rbind(upstream1,c(mastertable1[i,1],as.numeric(mastertable1[i,2:17]),mastertable1[i,18:26],""))}
    else {upstream1nometab <- rbind(upstream1nometab,c(mastertable1[i,1],as.numeric(mastertable1[i,2:17]),mastertable1[i,18:26],""))}
  }
  if(sum(as.numeric(mastertable1[i,2:17]))==0 && mastertable1[i,19]=="") {Nothing1 <- rbind(Nothing1,c(mastertable1[i,1],as.numeric(mastertable1[i,2:17]),mastertable1[i,18:26],""))}
  if(mastertable1[i,19]!="") {
    index <- grep(gsub(" ","",mastertable1[i,1]),gapgenes1[,1])
    if(length(index)!=0) {
      Missing1 <- rbind(Missing1,c(mastertable1[i,1],as.numeric(mastertable1[i,2:17]),mastertable1[i,18:26],gapgenes1[index[1],4]))
      if (length(index) > 1) {
        newvalue <- sum(as.numeric(gapgenes1[index,4]))/length(gapgenes1[index,4])
        if (newvalue > 1) {newvalue=1}
        Missing1[length(Missing1)] <- newvalue
      }
    } else {Present1 <- rbind(Present1,c(mastertable1[i,1],as.numeric(mastertable1[i,2:17]),mastertable1[i,18:26],""))}
  }
}

mastertable1 <- cbind(mastertable1,maxratio1)
# Takes the absolute max log ratio and concatenates it to the mastertable. Repeated below.

didntalign1 <- mat.or.vec(length(mastertable1[,1]),1)
for(i in 1:length(mastertable1[,1])) {
  index = match(mastertable1[i,1],gapgenes1[,1])
  if(!is.na(index)) {
    if(sum(as.numeric(mastertable1[i,2:17]))==0) {
      mastertable1[i,2:17]=NA
    }
    didntalign1[i] = "Did not align"
  } else {
    didntalign1[i] = "Aligned"
  }
}
# Concatenates information from the missing genes datasets (gapgenes1 and gapgenes2) into the mastertables. Repeated below.

mastertable1 = cbind(mastertable1,didntalign1)
rownames(mastertable1) = NULL
colnames(mastertable1) <- c("Vimss ID","Upstream",rep("",3),"Synonymous",rep("",3),"Nonsynonymous",rep("",3),"Downstream",rep("",3),"EC numbers","Names of metabolites","Log2 ratio","p-value","SD test","SD ref","TF binding sites","Sigma sites","Is mapped to ortholog","Max ratio","Didn't align")

write.table(mastertable1,"511145.mastertable.txt",sep="\t",col.names=NA)

rownames(codingsnp1) <- c(rep("Coding with metabolites",length(codingsnp1[,1])))
rownames(codingsnp1nometab) <- c(rep("Coding without metabolites",length(codingsnp1nometab[,1])))
rownames(upstream1) <- c(rep("Upstream with metabolites",length(upstream1[,1])))
rownames(upstream1nometab) <- c(rep("Upstream without metabolites",length(upstream1nometab[,1])))
rownames(Nothing1) <- c(rep("No SNPs and no metabolites",length(Nothing1[,1])))
rownames(Missing1) <- c(rep("Missing genes and metabolites",length(Missing1[,1])))
rownames(Present1) <- c(rep("Present genes and metabolites",length(Present1[,1])))

data1 = rbind(codingsnp1,codingsnp1nometab,upstream1,upstream1nometab,Nothing1,Missing1,Present1)

columns <- c("Vimss ID","Upstream",rep("",3),"Synonymous",rep("",3),"Nonsynonymous",rep("",3),"Downstream",rep("",3),"EC numbers","Names of metabolites","Log2 ratio","p-value","SD test","SD ref","TF binding sites","Sigma sites","Is mapped to ortholog","Fraction Missing")
colnames(data1) = columns
write.table(data1,file="511145_Important_Data.txt",sep = "\t",col.names=NA)

codingsnp2 <- NULL
codingsnp2nometab <- NULL
upstream2 <- NULL
upstream2nometab <- NULL
Nothing2 <- NULL
Missing2 <- NULL
Present2 <- NULL
maxratio2 <- NULL
for(i in 1:length(mastertable2[,1])) {    
  if(length(grep(",",mastertable2[i,20]))!=0) {
    ratios <- strsplit(mastertable2[i,20],",")[[1]]
    absmax = which.max(abs(as.numeric(ratios)))
    maxratio2 <- c(maxratio2,ratios[absmax])  
  } else {maxratio2 <- c(maxratio2, mastertable2[i,20])}
  if(sum(as.numeric(mastertable2[i,6:9]))>0){
    if(mastertable2[i,19]!="") {codingsnp2 <- rbind(codingsnp2,c(mastertable2[i,1],as.numeric(mastertable2[i,2:17]),mastertable2[i,18:26],""))} 
    else {codingsnp2nometab <- rbind(codingsnp2nometab,c(mastertable2[i,1],as.numeric(mastertable2[i,2:17]),mastertable2[i,18:26],""))}
  }
  if(sum(as.numeric(mastertable2[i,6:9]))==0 && sum(as.numeric(mastertable2[i,2:5]))>0) {
    if(mastertable2[i,19]!="") {upstream2 <- rbind(upstream2,c(mastertable2[i,1],as.numeric(mastertable2[i,2:17]),mastertable2[i,18:26],""))}
    else {upstream2nometab <- rbind(upstream2nometab,c(mastertable2[i,1],as.numeric(mastertable2[i,2:17]),mastertable2[i,18:26],""))}
  }
  if(sum(as.numeric(mastertable2[i,2:17]))==0 && mastertable2[i,19]=="") {Nothing2 <- rbind(Nothing2,c(mastertable2[i,1],as.numeric(mastertable2[i,2:17]),mastertable2[i,18:26],""))}
  if(mastertable2[i,19]!="") {
    index <- grep(gsub(" ","",mastertable2[i,1]),gapgenes2[,1])
    if(length(index)!=0) {
      Missing2 <- rbind(Missing2,c(mastertable2[i,1],as.numeric(mastertable2[i,2:17]),mastertable2[i,18:26],gapgenes2[index[1],4]))
      if (length(index) > 1) {
        newvalue <- sum(as.numeric(gapgenes2[index,4]))/length(gapgenes2[index,4])
        if (newvalue > 1) {newvalue=1}
        Missing2[length(Missing2)] <- newvalue
      }
    } else {Present2 <- rbind(Present2,c(mastertable2[i,1],as.numeric(mastertable2[i,2:17]),mastertable2[i,18:26],""))}
  }
}

mastertable2 <- cbind(mastertable2,maxratio2)

didntalign2 <- mat.or.vec(length(mastertable2[,1]),1)
for(i in 1:length(mastertable2[,1])) {
  index = match(mastertable2[i,1],gapgenes2[,1])
  if(!is.na(index)) {
    if(sum(as.numeric(mastertable2[i,2:17]))==0) {
      mastertable2[i,2:17]=NA
    }
    didntalign2[i] = "Did not align"
  } else {
    didntalign2[i] = "Aligned"
  }
}

mastertable2 = cbind(mastertable2,didntalign2)
rownames(mastertable2) = NULL
colnames(mastertable2) <- c("Vimss ID","Upstream",rep("",3),"Synonymous",rep("",3),"Nonsynonymous",rep("",3),"Downstream",rep("",3),"EC numbers","Names of metabolites","Log2 ratio","p-value","SD test","SD ref","TF binding sites","Sigma sites","Is mapped to ortholog","Max ratio","Didn't align")

write.table(mastertable2,"331112.mastertable.txt",sep="\t",col.names=NA)

rownames(codingsnp2) <- c(rep("Coding with metabolites",length(codingsnp2[,1])))
rownames(codingsnp2nometab) <- c(rep("Coding without metabolites",length(codingsnp2nometab[,1])))
rownames(upstream2) <- c(rep("Upstream with metabolites",length(upstream2[,1])))
rownames(upstream2nometab) <- c(rep("Upstream without metabolites",length(upstream2nometab[,1])))
rownames(Nothing2) <- c(rep("No SNPs and no metabolites",length(Nothing2[,1])))
rownames(Missing2) <- c(rep("Missing genes and metabolites",length(Missing2[,1])))
rownames(Present2) <- c(rep("Present genes and metabolites",length(Present2[,1])))

data2 = rbind(codingsnp2,codingsnp2nometab,upstream2,upstream2nometab,Nothing2,Missing2,Present2)

columns <- c("Vimss ID","Upstream",rep("",3),"Synonymous",rep("",3),"Nonsynonymous",rep("",3),"Downstream",rep("",3),"EC numbers","Names of metabolites","Log2 ratio","p-value","SD test","SD ref","TF binding sites","Sigma sites","Is mapped to ortholog","Fraction Missing")
colnames(data2) = columns
write.table(data2,file="331112_Important_Data.txt",sep = "\t",col.names=NA)


mismatch = NULL
sequence1 = 0
sequence2 = 0
percent = 100
query = ""

for(i in 1:length(blast[,1])) {
  line = strsplit(as.character(blast[i,1])," ")[[1]]
  printline = as.character(blast[i,1])
  if(length(line)==11 && line[11]=="letters)") {
    number = gsub("\\(","",line[10])
    printline = paste(printline,"checked")
  }
  if(!is.na(match("Query=",line))) {
    query = line[2]
    sequence1 = 0
    sequence2 = 0
    percent = 100
    printline = paste(printline,"checked")
  }
  if(!is.na(match("Identities",line))&&percent==100) {
    if(strsplit(line[4],"/")[[1]][2]==number) {
      percent = gsub("\\(","",line[5])
      percent = gsub("\\)","",percent)
      if(length(grep(",",percent)!=0)) {percent = gsub(",","",percent)}
      percent = as.numeric(gsub("%","",percent))
      printline = paste(printline,"checked")
    }
  }
  if(!is.na(match("Query:",line))&& percent<100) {
    sequence1 = line[which(line!="")][3]
    printline = paste(printline,"checked")
  }
  if(!is.na(match("Sbjct:",line))&& percent<100) {
    sequence2 = line[3]
    index1 = line[2]
    index2 = line[4]
    printline = paste(printline,"checked")
  }
  if(sequence1!=0 && sequence2!=0 && query!="" && percent<100) {
    mismatch = rbind(mismatch,cbind(query, percent, sequence1, sequence2, index1, index2))
    sequence1 = 0
    sequence2 = 0
    percent = 100
    printline = paste(printline,"checked")
  }
}
# Parses the blast output. 

blastindex = NULL
queries = NULL

for(i in 1:length(mismatch[,1])) {
  sequence1 = strsplit(mismatch[i,3],"")[[1]]
  sequence2 = strsplit(mismatch[i,4],"")[[1]]
  index = which(sequence1!=sequence2)
  if(length(index)!=0){
    for(j in index) {
      blastindex = rbind(blastindex,cbind(as.numeric(mismatch[i,5]),j,as.numeric(mismatch[i,6]),i))
      queries = rbind(queries,cbind(mismatch[i,1],mismatch[i,3],mismatch[i,4]))
    }
  }
}
# Finds the index of the blast mismatches in each TF sequence.

orig_blastindex = blastindex
for(char in 1:length(seq1)){
  if (seq2[char] == "-") {
    blastindex[which(blastindex[,1] >= char),1] = blastindex[which(blastindex[,1] >= char),1]+1
    blastindex[which(blastindex[,3] >= char),3] = blastindex[which(blastindex[,3] >= char),3]+1
  }
}
# Converts the blast indices to the aligned coordinates.

distances = mat.or.vec(length(tab2[,1]),1)
TFmutation = mat.or.vec(length(blastindex[,1]),5)
for(i in 1:length(blastindex[,1])){
  first = blastindex[i,1]
  last = blastindex[i,3]
  seqfrag1 = seq1[first:last]
  seqfrag2 = seq2[first:last]
  if(first>last) {
    snpindex = orig_blastindex[i,1] - blastindex[i,2] + 1
    for(j in 1:length(seqfrag1)) {
      if(seqfrag1[j]=="A") {seqfrag1[j]="T"}
      else if(seqfrag1[j]=="T") {seqfrag1[j]="A"}
      else if(seqfrag1[j]=="C") {seqfrag1[j]="G"}
      else if(seqfrag1[j]=="G") {seqfrag1[j]="C"}
    }
    for(j in 1:length(seqfrag2)) {
      if(seqfrag2[j]=="A") {seqfrag2[j]="T"} 
      else if(seqfrag2[j]=="T") {seqfrag2[j]="A"}
      else if(seqfrag2[j]=="C") {seqfrag2[j]="G"}
      else if(seqfrag2[j]=="G") {seqfrag2[j]="C"}
    }
  }else{snpindex = orig_blastindex[i,1] + blastindex[i,2] - 1}
  if(paste(seqfrag1,collapse="")==toupper(mismatch[blastindex[i,4],3]) && paste(seqfrag2,collapse="")==toupper(mismatch[blastindex[i,4],4])) { 
    for(j in 1:length(tab2[,1])) {
      distance = abs(tab2[j,5] - snpindex)
      distances[j] = distance
    }
    geneindex = which.min(distances)
    distances = mat.or.vec(length(tab2[,1]),1)
    if(mastertable2[geneindex,26]!="no ortholog") {
      genename = tab1$name[match(mastertable2[geneindex,26],as.character(tab1$locusId))]
      candidates = which(TFsite$V10 == queries[i,1])
      for(k in candidates) {
        sequence = strsplit(as.character(TFsite$V12[k]),"")[[1]]
        sequence = tolower(paste(sequence[which(sequence==toupper(sequence))],collapse=""))
        if(sequence == queries[i,2]) {
          TFgenenames = TFgene$V2[which(as.character(TFgene$V1)==TFsite$V2[k])]
          for(l in 1:length(TFsite$V12)) {
            seqindex1 = grep(toupper(queries[i,2]),as.character(TFsite$V12[l]))
            if(length(seqindex1)!=0) {
              if(TFsite$V2[seqindex1]=="MazE") {print(queries[i,3])}
              TFnames = c(TFnames,as.character(TFsite$V2[l]))
              break
            }
          }
        }
      }
      if(!is.na(match(genename,TFgenenames))) {
        TFmutation[i,1] = mastertable2[geneindex,26]
        TFmutation[i,2] = snpindex
        TFmutation[i,3] = mastertable2[geneindex,1]
        TFmutation[i,4] = paste(TFnames,collapse=",")
        TFnames=NULL
        TFmutation[i,5] = as.character(tab1$name[match(TFmutation[i,1],tab1[,1])])
      }
    }
  }
}
# Matches the TF sequence mismatches to the SNP indices.

TFmutation = TFmutation[which(TFmutation[,1]!="0"&TFmutation[,2]!="0"&TFmutation[,3]!="0"),]
# Filters out rows which had no TF mutations.

mastertable1_snps = mastertable1[which(rowSums(apply(mastertable1[,2:17],c(1,2),as.numeric))>0),]
# Filters for all the mastertable genes with positive count of SNPs and adds to mastertable1_snps.

mastertable1_filter_add = NULL
for(i in 1:length(TFmutation[,1])) {
  if(is.na(match(TFmutation[i,1],mastertable1_snps[,1]))) {
    mastertable1_filter_add = mastertable1[match(TFmutation[i,1],mastertable1[,1]),]
  }
}
# Further filters out mastertable1_snps for only genes with positive SNPs AND TF mutations associated.

mastertable1_filter = mastertable1_snps

nametable <- table(mastertable1_filter[,19])  ### Interesting cases filtered by looking for cases of less than 4 metabolites being repeated. Filtered for SNP presence too.
extract <- nametable[which(nametable < 4)]
extractnames <- dimnames(extract)[[1]]
namematch <- NULL
for (i in 1:length(extractnames)) {
  index <- grep(extractnames[i],mastertable1_filter[,19])
  if (length(index)!=0) {namematch <- rbind(namematch,mastertable1_filter[index,])}
}
# Creates the summary (or interesting cases) table.
summary1=namematch

summary2 = mat.or.vec(dim(summary1)[1],dim(mastertable2)[2])
for(i in 1:length(summary1[,1])) {
  index1 = match(summary1[i,1],orth1[,1])
  index2 = match(orth1[index1,2],orth2[,1])
  if(!is.na(orth1[index1,1]) && !is.na(orth2[index2,2])) {
    index = match(orth1[index1,2],mastertable2[,1])
    summary2[i,] = mastertable2[index,]
    if(is.na(summary2[i,1])) {
      if(sum(as.numeric(summary1[i,2:5]))>0) {
        index = match(summary1[i,1],upstr1[,1])
        vimss = upstr2[index,1]
        index = which(mastertable2[,1]==vimss)
        summary2[i,] = mastertable2[index,]
      }
      if(sum(as.numeric(summary1[i,6:13]))>0) {
        index = match(summary1[i,1],coding1_vimss)
        vimss = coding2_vimss[index]
        index = which(mastertable2[,1]==vimss)
        summary2[i,] = mastertable2[index,]
      }
      if(sum(as.numeric(summary1[i,14:17]))>0) {
        index = match(summary1[i,1],downstr1[,1])
        vimss = downstr2[index,1]
        index = which(mastertable2[,1]==vimss)
        summary2[i,] = mastertable2[index,]
      }
    }
  }
}

genename1 = NULL
annotation1 = NULL
genename2 = NULL
annotation2 = NULL

for(i in 1:length(summary1[,1])) {
  index1 = match(summary1[i,1],tab1[,1])
  genename1 = c(genename1,as.character(tab1$name[index1]))
  annotation1 = c(annotation1,as.character(tab1$COGDesc[index1]))
  index2 = match(summary2[i,1],tab2[,1])
  genename2 = c(genename2,as.character(tab2$name[index2]))
  annotation2 = c(annotation2,as.character(tab2$COGDesc[index2]))
}
# Concatenates the annotation from the MO tab file to each gene in the summary table.

stopit = F
direction1 = mat.or.vec(length(summary1[,1]),1)
for(i in 1:length(summary1[,1])) {
  eclist = strsplit(summary1[i,18],",")[[1]]
  for(j in eclist) {
    index1 = grep(j,mapper[,5],fixed=T)
    if(length(index1)!=0) {
      for(k in index1) {
        index2 = which(as.character(northen[,6])==as.character(mapper[k,8]))
        if(length(index2)!=0) {
          for(l in index2) {
            metabolites = summary1[i,19]
            if(length(grep(",",summary1[i,19]))!=0){metabolites = strsplit(as.character(summary1[i,19])," , ")[[1]]}
            if(length(which(as.character(metabolites)==as.character(northen[l,1])))!=0){
              reaction = strsplit(as.character(mapper[k,7])," ")[[1]]
              arrow = which(reaction == "<=>")
              compound = as.character(mapper[k,2])
              if(length(grep(" ",compound))!=0) {compound = strsplit(compound," ")[[1]][1]}
              if(length(reaction)!=0 && length(compound)!=0 && length(arrow)!=0) {
                if(which(reaction == compound) < arrow) {direction1[i] = "reactant"}
                if(which(reaction == compound) > arrow) {direction1[i] = "product"}
                stopit = T
                break
              }
            }
          }
        }
        if(stopit) {
          stopit=F
          break
        }
      }
      if(stopit) {
        stopit=F
        break
      }
    }
  }
}
# Looks through each gene in the summary table and maps its associated EC number to the EC number in
# Bill Riehl's file, and gives that EC number the value reactant or product depending on the direction
# of the reaction. Reactant if the associated metabolite with the EC number is a reactant. Product if it's
# a product. Repeated below for the other strain.

stopit = F
direction2 = mat.or.vec(length(summary2[,1]),1)
for(i in 1:length(summary2[,1])) {
  eclist = strsplit(summary2[i,18],",")[[1]]
  for(j in eclist) {
    index1 = grep(j,mapper[,5],fixed=T)
    if(length(index1)!=0) {
      for(k in index1) {
        index2 = which(as.character(northen[,6])==as.character(mapper[k,8]))
        if(length(index2)!=0) {
          for(l in index2) {
            metabolites = summary2[i,19]
            if(length(grep(",",summary2[i,19]))!=0){metabolites = strsplit(as.character(summary2[i,19])," , ")[[1]]}
            if(length(which(as.character(metabolites)==as.character(northen[l,1])))!=0){
              reaction = strsplit(as.character(mapper[k,7])," ")[[1]]
              arrow = which(reaction == "<=>")
              compound = as.character(mapper[k,2])
              if(length(grep(" ",compound))!=0) {compound = strsplit(compound," ")[[1]][1]}
              if(length(reaction)!=0 && length(compound)!=0 && length(arrow)!=0) {
                if(which(reaction == compound) < arrow) {direction2[i] = "reactant"}
                if(which(reaction == compound) > arrow) {direction2[i] = "product"}
                stopit = T
                break
              }
            }
          }
        }
        if(stopit) {
          stopit=F
          break
        }
      }
      if(stopit) {
        stopit=F
        break
      }
    }
  }
}

amino = ""
nonsynonymous1 = mat.or.vec(length(summary1[,1]),1)
for(i in 1:length(summary1[,1])) {
  index = match(summary1[i,1],mastertable1[,1])
  if(sum(as.numeric(mastertable1[index,10:13]))>0) {
    index = which(prot1[,1]==summary1[i,1])
    for(j in index) {
      if(prot1[j,2] != prot2[j,2]) {
        change = paste(paste(prot2[j,2],prot2[j,3]),"->",paste(prot1[j,2],prot1[j,3]))
        if(amino=="") {amino = change}
        else {amino = paste(amino,", ",change)}
      }
    }
    nonsynonymous1[i] = amino
  }
  amino = ""
}
# Looks in the interesting cases table for genes with nonsynonymous mutations, then looks through 
# prot1 and prot2 which map each nonsynonymous mutation to the gene it's found in.
# It then takes all nonsynonymous mutations mapped to that gene in the interesting cases table and
# looks for the mutated amino acid in the other strain. It then makes a string showing mapping the
# nonsynonymous mutations with a directional arrow, depending on which strain in the master table you
# are currently looking at.
# The process is repeated below, except in the opposite direction.

amino = ""
nonsynonymous2 = mat.or.vec(length(summary2[,1]),1)
for(i in 1:length(summary2[,1])) {
  if(!is.na(summary2[i,1])) {
    index = match(summary2[i,1],mastertable2[,1])
    if(!is.na(index)&&sum(as.numeric(mastertable2[index,10:13]))>0) {
      index = which(prot2[,1]==summary2[i,1])
      for(j in index) {
        if(prot2[j,2] != prot1[j,2]) {
          change = paste(paste(prot1[j,2],prot1[j,3]),"->",paste(prot2[j,2],prot2[j,3]))
          if(amino == "") {amino = change}
          else {amino = paste(amino,", ",change)}
        }
      }
      nonsynonymous2[i] = amino
    }
  }
  amino = ""
}


writeit = cbind(summary1[,1],rowSums(apply(summary1[,2:5],c(1,2),as.numeric)),rowSums(apply(summary1[,6:9],c(1,2),as.numeric)),rowSums(apply(summary1[,10:13],c(1,2),as.numeric)),rowSums(apply(summary1[,14:17],c(1,2),as.numeric)),summary1[,18:27],genename1,annotation1,direction1,nonsynonymous1)
writeit = cbind(writeit,summary2[,1],rowSums(apply(summary2[,2:5],c(1,2),as.numeric)),rowSums(apply(summary2[,6:9],c(1,2),as.numeric)),rowSums(apply(summary2[,10:13],c(1,2),as.numeric)),rowSums(apply(summary2[,14:17],c(1,2),as.numeric)),summary2[,18:27],genename2,annotation2,direction2,nonsynonymous2)

write.table(writeit,"Summary of interesting cases MG1655 and HS.txt",sep="\t",row.names=F)
